<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas" width="300" height="300"></canvas>

    <script>
        async function init() {
            if (!navigator.gpu) {
                throw new Error('WebGPU not supported.');

            }
            const adapter = await navigator.gpu.requestAdapter()
            if (!adapter) {
                throw Error("Couldn't request WebGPU adapter.");
            }

            const device = await adapter.requestDevice()

            const canvas = document.getElementById('canvas');

            const ctx = canvas.getContext('webgpu')

            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

            ctx.configure({
                device,
                format: presentationFormat,
                alphaMode: 'premultiplied'
            })

            const pipeline = device.createRenderPipeline({
                layout: 'auto',

                vertex: {
                    module: device.createShaderModule({
                        code: `
                            @vertex
                            fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {
                                var pos = array<vec2<f32>, 3>(
    vec2(0.0, 0.5),
    vec2(-0.5, -0.5),
    vec2(0.5, -0.5)
  );

  return vec4<f32>(pos[VertexIndex], 0.0, 1.0);
                            }
                        `
                    }),
                    entryPoint: 'main'
                },

                fragment: {
                    module: device.createShaderModule({
                        code: `@fragment
fn main() -> @location(0) vec4<f32> {
  return vec4(1.0, 0.0, 0.0, 1.0);
}
`
                    }),
                    entryPoint: 'main',
                    targets: [
                        {
                            format: presentationFormat
                        }
                    ]
                },

                primitive: {
                    topology: 'triangle-list'
                }
            });

            const commandEncoder = device.createCommandEncoder();

            const passEncoder = commandEncoder.beginRenderPass({
                colorAttachments: [
                    {
                        view: ctx.getCurrentTexture().createView(),
                        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store'
                    }
                ]
            })

            passEncoder.setPipeline(pipeline);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.end();

            device.queue.submit([commandEncoder.finish()]);
        }


        init()
    </script>
</body>
</html>