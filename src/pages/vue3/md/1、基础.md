## vue3

1、`vue`通过`createApp`函数创建一个新的应用实例，传入一个组件`（包含组件选项的对象）`作为参数，必须通过调用`.mount()`才能渲染出来

```js
import { createApp } from 'vue'
const app = createApp({
    // 组件属性选项
});
// 参数可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串
app.$mount('#app');
```

2、`v-bind`同名简写 <sup>`3.4+`</sup>

```html
<!-- 3.4之前 -->
<div v-bind:id="id"></div>
<div :id="id"></div>
<!-- 3.4之后 -->
<div :id></div>
```

3、`ref`与`reactive`声明响应式状态，如果需要在模板中使用请在`setup`中返回

`reactive`局限性
- 仅接受对象（对象，数组，Map，Set）
- 不能替换整个对象
- 对解构操作不友好

```js
setup() {
    // 推荐使用 ref，可支持简单类型与复杂类型的响应式处理
    const obj = ref({ num: 1 });
    // 仅接受对象（对象，数组，Map，Set）
    const data = reactive({ num: 1 });
    const increment = () => {
        // ref声明的响应式需要.value进行访问，模板中不需要.value，会自动解包
        obj.value.num ++;
        // 而reactive则不需要.value
        data.num ++;
    }
    return {
        count,
        increment
    }
}
```

4、`computed` 计算属性

**计算属性值会基于其响应式依赖被缓存**，计算属性会返回一个 `ref` 对象，可通过 `.value` 访问

```js
// 返回 ref
const publishedBooksMessage = computed(() => {
    return author.books.length > 0 ? 'Yes' : 'No'
})
```

5、类`class`与样式`style`绑定

`vue2` 组件只有一个根元素，写在组件上的 `class` 与 `style` 会自动绑定到组件内部根元素上，但是 `vue3` 组件允许多根元素，当不止一个根元素时，需要在内部指定哪个根元素来接收

```js
<HelloWorld class="red" style="color:blue"></HelloWorld>

// HelloWorld 组件
<template>
    <p :style="$attrs.style">p</p>
    <span :class="$attrs.class">span</span>
</template>
```

6、生命周期函数

- `onBeforeMount` 在组件被挂载之前被调用
- <font style="color:red">**onMounted**</font> 在组件挂载完成后被调用
- `onBeforeUpdate` 在组件即将因为响应式状态变更而更新其 DOM 树之前调用
- <font style="color:red">**onUpdated**</font> 组件因为响应式状态变更而更新其 DOM 树之后调用
- `onBeforeUnmount` 在组件实例被卸载之前调用
- <font style="color:red">**onUnmounted**</font> 在组件实例被卸载之后调用
- onErrorCaptured 捕获了后代组件传递的错误时调用
- onRenderTracked 调试钩子
- onRenderTriggered 调试钩子
- <font style="color:red">**onActivated**</font> `keep-alive` 缓存被激活时触发
- <font style="color:red">**onDeactivated**</font>

7、访问模板引用 `ref`

```vue
<!-- 同名变量 -->
<div ref="name"></div>
<!-- 函数模板引用 -->
<component :is="tab" :ref="(el) => setRef(el)"></component>
<!-- 组件上的 ref -->
<Child ref="child"></Child>
```
```js
setup() {
    // 声明一个 ref 来存放该元素的引用，必须和模板里的 ref 同名
    const name = ref(null);
    const child = ref(null);

    const setRef = (el) => {
        // 将 el 赋值给一个数据属性或 ref 变量
        name.value = el;
    }
    return {
        name,
        setRef,
        // child.value 是组件实例
        child
    }
}
```
