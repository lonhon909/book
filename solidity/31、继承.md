# 继承


```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
// 基类
contract A {
    // virtual 关键字表示可以被重写
    function foo() public pure virtual returns (string memory) {
        return 'A';
    }
    function bar() public pure virtual returns (string memory) {
        return 'A';
    }
    function baz() public pure returns (string memory) {
        return 'A';
    }
}
// B 继承 A
contract B is A {
    // override 关键字表示该函数为重写基类方法
    function foo() public pure override returns (string memory) {
        return 'B';
    }
    // virtual override 两个关键字表示该方法是重写基类的同名方法，并且也允许被子类重写
    function bar() public pure virtual override returns (string memory) {
        return 'B';
    }
}
// C 继承 B
contract C is B {
    function bar() public pure override returns (string memory) {
        return 'C';
    }
}
```

## 多线继承

```js
// 多线继承，越基础的基类越放前面
contract D is A, B {
    // override(A, B) 表示同时覆盖A, B中的 foo 函数
    function foo() public pure override(A, B) returns (string memory) {
        return 'D';
    }
    function bar() public pure override(A, B) returns (string memory) {
        return 'D';
    }
}
```

## 基类被继承时，基类的构造函数怎么执行
```js
// 基类
contract A {
    string public name;
    constructor(string memory _name) {
        name = _name;
    }
}
// 基类
contract B {
    uint public age;
    constructor(uint _age) {
        age = _age;
    }
}
// 基类有构造函数并且要求参数初始化，可以在继承时直接传入
contract C is A(''), B(20) {

}
// 如果基类构造函数初始化参数是动态的，可以在子类构造函数后面传入参数初始化
contract D is A, B {
    constructor(string memory _name, uint _age) A(_name) B(_age) {}
}
// 也可以混合传入参数
contract E is A(''), B {
    constructor(uint _age) B(_age) {}
}
```